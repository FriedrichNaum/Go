PARSER_BEGIN(Go)

public class Go {
    public static void main(String[] args) throws ParseException {
        Go lexer = new Go(System.in);
        Token token;
        while ((token = lexer.getNextToken()).kind != GoConstants.EOF) {
            switch (token.kind) {
                case GoConstants.ID:
                    System.out.println("ID " + token.image);
                    break;
                case GoConstants.NUM_DEC:
                    System.out.println("NUM_DEC " + token.image);
                    break;
                case GoConstants.KEYWORD:
                    System.out.println("KEYWORD " + token.image);
                    break;
                case GoConstants.OPERATOR:
                    System.out.println("OPERATOR " + token.image);
                    break;
                case GoConstants.DELIMITER:
                    System.out.println("DELIMITER " + token.image);
                    break;
                case GoConstants.STRING:
                    System.out.println("STRING " + token.image);
                    break;
                case GoConstants.SINGLE_LINE_COMMENT:
                    System.out.println("SINGLE_LINE_COMMENT " + token.image);
                    break;
                case GoConstants.MULTI_LINE_COMMENT:
                    System.out.println("MULTI_LINE_COMMENT " + token.image);
                    break;
                case GoConstants.WHITESPACE:
                    // Ignore whitespace tokens
                    break;
                
                default:
                    System.out.println("UNKNOWN " + token.image);
                    break;
            }
        }
    }
}

PARSER_END(Go)

SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\r"
}

MORE :
{
    < WHITESPACE: ( " " | "\t" | "\n" | "\r" )+ >
|   < SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r") >
|   < MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["/"] | "/" ~["*"])* "*" "/" >
}

TOKEN :
{
    < ID: <LETTER> (<LETTER> | <DIGIT> | "_")* >
|   < NUM_DEC: <DIGIT> ("." <DIGIT>)? >
|   < KEYWORD:
        "break" | "default" | "func" | "interface" | "select" |
        "case" | "defer" | "go" | "map" | "struct" |
        "chan" | "else" | "goto" | "package" | "switch" |
        "const" | "fallthrough" | "if" | "range" | "type" |
        "continue" | "for" | "import" | "return" | "var"
    >
|   < OPERATOR: "==" | "!=" | "<=" | ">=" | "&&" | "||" | "<<" | ">>" | "&^" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "&^=" | "<-" |
                 "++" | "--" | ":=" | "..." |
                 "+" | "-" | "*" | "/" | "%" | "&" | "|" | "^" |
                 "!" | "<" | ">" | "=" >
|   < INT_LIT: <DECIMAL_LIT> | <BINARY_LIT> | <OCTAL_LIT> | <HEXA_LIT>>
|   < DECIMAL_LIT: "0" | (<DIGIT>) [["_"]<DECIMAL_DIGITS>]>
|   < BINARY_LIT: "0" ("b" | "B") ["_"]<BINARY_DIGITS>>
|   < OCTAL_LIT: "0"  ["o" | "O"] ["_"]<OCTAL_DIGITS>>
|   < FLOAT_LIT: <DECIMAL_FLOAT_LIT> | <HEXA_FLOAT_LIT>>
|   < DECIMAL_FLOAT_LIT: <DECIMAL_DIGITS>"."[ <DECIMAL_DIGITS>][<DECIMAL_EXPONENT>] | <DECIMAL_DIGITS><DECIMAL_EXPONENT>| "."<DECIMAL_DIGITS>[<DECIMAL_EXPONENT>]>
|   < DECIMAL_EXPONENT: ("e" | "E") ["+" | "-"] <DECIMAL_DIGITS>>
|   < HEXA_FLOAT_LIT: "0" ("x" | "X") ["_"]<HEXA_MANTISSA><HEXA_EXPONENT>>
|   < HEXA_MANTISSA: ["_"]<HEXA_DIGITS>"." [<HEXA_DIGITS>] | ["_"]<HEXA_DIGITS> | "."<HEXA_DIGITS>>
|   < HEXA_EXPONENT: ("p" | "P")["+" | "-"]<DECIMAL_DIGITS>>
|   < IMAGINARY_LIT: (<DECIMAL_DIGITS> | <INT_LIT> | <FLOAT_LIT>)"i">
|   < DELIMITER: "{" | "}" | "(" | ")" | "[" | "]" | "," | ";" | "." >
|   < STRING: "\"" (~["\""])* "\"" >
|   < RUNE_LIT: "'" ( UNICODE_VALUE | BYTE_VALUE ) "'"> 
|   < TYPE: <TYPENAME> [ <TYPEARGS> ] | <TYPELIT> | "(" <TYPE> ")">
|   < TYPENAME: <IDENTIFIER> | <QUALIFIEDIDENT>>
|   < TYPEARGS: "[" <TYPELIST> [","] "]">
|   < TYPELIST: <TYPE> {","<TYPE>}>
|   < TYPELIT: <ARRAYTYPE> | <STRUCTTYPE> | <POINTERTYPE> | <FUNCTIONTYPE> | <INTERFACETYPE> | <SLICETYPE> | <MAPTYPE> | <CHANNELTYPE>>
|   < ARRAYTYPE: "[" <ARRAYLENGHT> "]" <ELEMENTTYPE>>
|   < ARRAYLENGHT: <EXPRESSION>>
|   < ELEMENTTYPE: <TYPE>>
|   < SLICETYPE: "[" "]" <ELEMENTTYPE>>
|   < STRUCTTYPE: "struct" "{" {<FIELDECL> ";" } "}">
|   < FIELDECL: (<IDENTIFIERLIST> <TYPE> | <EMBEDDEDFIELD>) [<TAG>]>
|   < EMBEDDEDFIELD: [ "*" ] <TYPENAME> [ <TYPEARGS> ] >
|   < TAG: <STRINGLIT>>
|   < POINTERTYPE: "*" <BASETYPE>>
|   < FUNCTIONTYPE: "func" <SIGNATURE>>
|   < INTERFACETYPE: "interface" "{" { <INTERFACEELEM>";"} "}">
|   < MAPTYPE: "map" "[" <KEYTYPE> "]" <ELEMENTTYPE>>
|   < CHANNELTYPE: ( "chan" | "chan" "<-" | "<-" "chan" ) <ELEMNTTYPE>>
|   < BLOCK: "{" <STATEMENT> "}">
|   < DECLARATION: <CONSTDECL> | <TYPEDECL> | <VARDECL>>
|   < CONSTDECL: "const" (<CONSTSPEC> | "("{<CONSTSPEC>";" } ")")>
|   < TYPEDECL: "type" ( <TYPESPEC> | "(" {<TYPESPEC> ";" } ")" )>
|   < ALIASDECL: <IDENTIFIER> | <TYPEDEF>>
|   < TYPEDEF: <IDENTIFIER> [ <TYPEPARAMETERS> ] <TYPE>>
|   < TYPEPARAMETERS: "[" <TYPEPARAMLIST> [","] "]">
|   < TYPECONSTRAINT: <TYPEELEM>>
|   < VARDECL: "var" (<VARSPEC> | "(" { <VARSPEC> ";"} ")" )>
|   < FUNCTIONDECL: "func" <FUNCTIONNAME> [ <TYPEPARAMETERS>] <SIGNATURE> [<FUNCTIONBODY>]>
|   < METHODDECL: "func" <RECEIVER> <METHODNAME> <SIGNATURE> [<FUNCTIONBODY>]>
|   < OPERAND: <LITERAL> | <OPERANDNAME> [ <TYPEARGS> ] | "(" <EXPRESSION> ")">
|   < LITERAL: <BASICLIT> | <COMPOSITELIT> | <FUNCTIONLIT>>
|   < BASICLIT: <INT_LIT> | <FLOAT_LIT> | <IMAGINARY_LIT> | <RUNE_LIT> | <STRINGLIT>>
|   < OPERANDNAME: <IDENTIFIER> | <QUALIFIEDIDENT>>
|   < QUALIFIEDIDENT: <PACKAGENAME> "." <IDENTIFIER>>
|   < COMPOSITELIT: <LITERALTYPE> <LITERALVALUE>>
|   < LITERALTYPE: <STRUCTTYPE> | <ARRAYTYPE> | "[" "..." "]" <ELEMENTTYPE> | <SLICETYPE> | <MAPTYPE> | <TYPENAME> [<TYPEARGS>]>
|   < LITERALVALUE: "{" [ <ELEMENTLIST> [","] ] "}">
|   < ELEMENTLIST: <KEYEDELEMENT> { "," <KEYEDELEMENT> }>
|   < KEYEDELEMENT: [ <KEY> ":" ]<ELEMENT>>
|   < KEY: <FIELDNAME> |  <EXPRESSION> | <LITERALVALUE>>
|   < FIELDNAME: <IDENTIFIER>>
|   < ELEMENT: <EXPRESSION> | <LITERALVALUE>>
|   < FUNCTIONLIT: "func" <SIGNATURE> <FUNCTIONBODY>>
|   < PRIMARYEXPR: <OPERAND> | <CONVERSION> | <METHODEXPR> | <PRIMARYEXPR> <SELECTOR> | <PRIMARYEXPR> <INDEX> | <PRIMARYEXPR> <SLICE> | <PRIMARYEXPR> <TYPEASSERTION> | <PRIMARYEXPR> <ARGUMENTS>>
|   < SELECTOR: "." <IDENTIFIER>>
|   < INDEX: "[" <EXPRESSION> [","] "]">
|   < SLICE: "[" [<EXPRESSION>] ":" [<EXPRESSION>] "]" | "[" [<EXPRESSION>] ":" <EXPRESSION> ":" <EXPRESSION> "]">
|   < TYPEASSERTION: "." "(" <TYPE> ")">
|   < ARGUMENTS: "(" [ ( <EXPRESSIONLIST> | <TYPE> ["," <EXPRESSIONLIST>]) ["..."][","]] ")">
|   < METHODEXPR: <RECEVERTYPE> "." <METHODNAME>>
|   < RECEVERTYPE: <TYPE>>
|   < EXPRESSION: <UNARYEXPR> | <EXPRESSION> <BINARY_OP> <EXPRESSION>>
|   < UNARYEXPR: <PRIMARYEXPR> | <UNARY_OP> <UNARYEXPR>>
|   < BINARY_OP: "||" | "&&" | <REL_OP> | <ADD_OP> | <MUL_OP>>
|   < REL_OP: "==" | "!=" | "<" | "<=" | ">" | ">=">
|   < ADD_OP: "+" | "-" | "|" | "^">
|   < MUL_OP: "*" | "/" | "%" | "<<" | ">>" | "&" | "&^">
|   < UNARY_OP: "+" | "-" | "!" | "^" | "*" | "&" | "<-">
|   < CONVERSION: <TYPE> "(" <EXPRESSION> [","] ")">
|   < STATEMENT: <DECLARATION> | <LABELEDSTMT> | <SIMPLESTMT> | <GOSTMT> | <FALLTHROWGHSTMT> | <BLOCK> | <IFSTMT> | <SWITCHSTMT> | <SELECTSTMT> | <FORSTMT> | <DEFERSTMT>>
|   < SIMPLESTMT: <EMPTYSTMT> | <EXPRESSIONSTMT> | <SENDSTMT> | <INCDECSTMT> | ASSIGMENT> | <SHORTVARDECL>>
|   < EMPTYSTMT: >
|   < LABELEDSTMT: <LABEL> ":" <STATEMENT>>
|   < LABEL: <IDENTIFIER>>
|   < EXPRESSIONSTMT: <EXPRESSION>>
|   < SENDSTMT: <CHANNEL> "<-" <EXPRESSION>>
|   < CHANNEL: <EXPRESSION>>
|   < INCDECSTMT: <EXPRESSION> ( "++" | "--")>
|   < ASSIGMENT: <EXPRESSIONLIST> <ASSIGN_OP> <EXPRESSIONLIST>>
|   < ASSIGN_OP: [ <ADD_OP> | <MUL_OP>]"=">
|   < IFSTMT: "if" [<SIMPLESTMT ";"] <EXPRESSION> <BLOCK> ["else" ( <IFSTMT> | <BLOCK>)]>
|   < SWITCHSTMT: <EXPRSWITCHSTMT> | <TYPESWITCHSTMT>>
|   < EXPRSWITCHSTMT: "switch" [ <SIMPLESTMT> ";"] [<EXPRESSION>]"{" {<EXPRCASECLAUSE>} "}">
|   < EXPRCASECLAUSE: <EXPRSWITCHCASE> ":" <STATEMENTLIST>>
|   < EXPRSWITCHCASE: "case" <EXPRESSIONLIST> | "default">
|   < TYPESWITCHSTMT: "switch" [<SIMPLESTMT> ";"] <TYPESWITCHGUARD> "{" {<TYPECASECLAUSE>} "}">
|   < TYPESWITCHGUARD: [<IDENTIFIER> ":="] <PRIMARYEXPR> "." "(" "type" ")">
|   < TYPECASECLAUSE: <TYPESWITCHCASE> ":" <STATEMENTLIST>>
|   < TYPESWITCHCASE: "case" <TYPELIST> | "default">
|   < FORSTMT: "for" [<CONDITION> | <FORCALUSE> | <RANGECLAUSE>] <BLOCK>>
|   < CONDITION: <EXPRESSION>>
|   < FORCALUSE: [<INITSTMT>] ";" [<CONDITION>] ";" [<POSTSTMT>]>
|   < INITSTMT: <SIMPLESTMT>>
|   < POSTSTMT: <SIMPLESTMT>>
|   < RANGECLAUSE: [<EXPRESSIONLIST> "=" | <IDENTIFIERLIST ":="] "range" <EXPRESSION>>
|   < GOSTMT: "go" <EXPRESSION>>
|   < SELECTSTMT: "select" "{" {<COMMCLAUSE>} "}">
|   < COMMCLAUSE = <COMMCASE> ":" <STATEMENTLIST>>
|   < COMMCASE: "case" (<SENDSTMT> | <RECVSTMT>) | "default">
|   < RECVSTMT: [<EXPRESSIONLIST> "=" | <IDENTIFIERLIST> ":="] <RECVEXPR>>
|   < RECVEXPR: <EXPRESSION>>
|   < RETURNSTMT: "return" [<EXPRESSIONLIST>]>
|   < BREAKSTMT: "break" [<LABEL>]>
|   < CONTINUESTMT: "continue" [<LABEL>]>
|   < GOTOSTMT: "goto" <LABEL>>
|   < FALLTHROWGHSTMT: "fallthrough">
|   < DEFERSTMT: "defer" <EXPRESSION>>
|   < SOURCEFILE: <PACKAGECLAUSE> ";" { <IMPORTDECL> ";"} {<TOPLEVELDECL> ";"}>
|   < PACKAGECLAUSE: "package" <PACKAGENAME>>
|   < PACKAGENAME: <IDENTIFIER>>
|   < IMPORTDECL: "import" (<IMPORTSPEC> | "(" {<IMPORTSPEC>} ")" )>
|   < IMPORTSPEC: ["." | <PACKAGENAME> ] <IMPORTPATH>>
|   < IMPORTPATH: <STRINGLIT>>
|   < UNICODE_VALUE: <UNICODE_CHAR> | <LITLE_U_VALUE> | <BIG_U_VALUE> | <ESCAPED_CHAR> 
|   < BYTE_VALUE: <OCTAL_BYTE_VALUE> | <HEX_BYTE_VALUE>> 
|   < OCTAL_BYTE_VALUE: '\' <OCTAL> <OCTAL> <OCTAL>> 
|   < HEX_BYTE_VALUE: '\' "x" <HEXA> <HEXA>> 
|   < LITLE_U_VALUE: '\' "u" <HEXA> <HEXA> <HEXA> <HEXA>> 
|   < BIG_U_VALUE: '\' "U" <HEXA> <HEXA> <HEXA> <HEXA> <HEXA>> 
|   < UNICODE_LETTER_CODEPOINT: ["\u0041"-"\u005A", "\u0061"-"\u007A"]> 
|   < UNICODE_DIGIT_CODEPOINT: ["\u0030"-"\u0039"]> 
|   < ESCAPED_CHAR: '\' ( "a" | "b" | "f" | "h" | "r" | "t" | "v" | '\' | "'" | '"')>
|   < RAW_STRING_LIT: "'" { <UNICODE_CHAR> | <NEWLINE> } "'"> 
|   < STRINGLIT: <RAW_STRING_LIT> | <INTERPRETED_STRING_LIT>>
|   < INTERPRETED_STRING_LIT: '"' {<UNICODE_VALUE> | <BYTE_VALUE>} '"'> 
|   < BASE_TYPE: <TYPE>> 
|   < SIGNATURE: <PARAMETERS> [ <RESULT> ]> 
|   < RESULT: <PARAMETERS> | <TYPE>>
|   < PARAMETERS: "(" [ <PARAMETERLIST> [ "," ] ] ")" > 
|   < PARAMETERLIST: <PARAMETERDECL> { "," <PARAMETERDECL> }> 
|   < PARAMETERDECL: [ <IDENTIFIERLIST> ] ["..."] <TYPE>> 
|   < UNDERLYINGTYPE: "~" <TYPE>> 
|   < TYPETERM: <TYPE> | <UNDERLYINGTYPE>> 
|   < TYPEELEM: <TYTERM> { "|" <TYPETERM> }> 
|   < METHODNAME: <IDENTIFIER>> 
|   < METHODELEM: <METHODNAME> <SIGNATURE>> 
|   < INTERFACEELEMEN: <METHODNAME> | <TYPELEM>> 
|   < KEYTYPE: <TYPE>> 
|   < STATEMENTLIST: { <STATEMENT> ";" }> 
|   < TOPLEVELDECL: <DECLARATION> | <FUNCTIONDECL> | <METHODDECL>>
|   < EXPRESSIONLIST: <EXPRESSION> { "," <EXPRESSION>}> 
|   < IDENTIFIERLIST: <IDENTIFIER> { "," <IDENTIFIER>}>>
|   < CONSTSPEC: <IDENTIFIERLIST> [[<TYPE>] "=" <EXPRESSIONLIST>]> 
|   < TYPEPARAMLIST: <TYPEPARAMDECL> {"," <TYPEPARAMDECL>}>
|   < TYPESPEC: <ALIASDECL> | <TYPEDEF>> 
|   < TYPEPARAMDECL: <IDENTIFIERLIST> <TYPECONSTRAINT>> 
|   < VARSPEC: <IDENTIFIERLIST> ( <TYPE> [ "=" <EXPRESSIONLIST> ] | "=" <EXPRESSIONLIST>)>
|   < FUNCTIONNAME: <IDENTIFIER> > 
|   < FUNCTIONBODY: <BLOCK>> 
|   < RECEIVER: <PARAMETERS>> 
}

TOKEN :
{
    < NEWLINE: "\u000A" >
|   < UNICODE_CHAR: "\u0000" - "\u0009" | "\u000B" - "\uFFFF" >
|   < UNICODE_LETTER: <UNICODE_LETTER_CODEPOINT> >
|   < UNICODE_DIGIT: <UNICODE_DIGIT_CODEPOINT> >
}

TOKEN :
{
    < #DIGIT: ["0"-"9"] >|
    < #BINARY: ["0"-"1"]>|
    < #OCTAL: ["0"-"7"]>|
    < #HEXA: ["0"-"9"| "A" - "F" | "a" - "f"]>|
    < #DECIMAL_DIGITS: <DIGIT>{["_"]}<DIGIT>>|
    < #BINARY_DIGITS: <BINARY>{["_"]}<BINARY>>|
    < #OCTAL_DIGITS: <OCTAL>{["_"]}<OCTAL>>|
    < #HEXA_DIGITS: <HEXA>{["_"]}<HEXA>> |
    < #LETTER: ["a"-"z", "A"-"Z", "_"] > 
}
